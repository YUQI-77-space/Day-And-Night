# 项目工程准备指南

> **项目代号：** DayAndNight（末日小镇生存游戏）  
> **Unity版本：** 2022.3.62f2c1  
> **目标：** 搭建符合大型游戏开发标准的专业项目架构  
> **适用：** Windows / macOS 双平台开发

---

## 📋 文档概述

本指南旨在帮助您从零开始搭建一个专业、稳定、可扩展的Unity游戏项目。我们将按照大型游戏的开发标准，构建模块化、可维护的项目架构。每个步骤都经过精心设计，确保您能够一次性完成所有配置，避免后期重构带来的额外工作。

### 核心目标

我们的首要任务是建立一个能够支撑游戏全生命周期开发的工程环境。这意味着项目需要具备以下核心特性：首先是**清晰的目录结构**，所有资源、代码、配置文件都有明确的归属，便于团队协作和代码审查；其次是**完善的版本控制**，通过Git进行精细化的代码管理，确保每一次提交都有据可查；第三是**标准化的开发流程**，从编码规范到测试流程，都有明确的指导方针。

### 适用人群

本指南适用于有一定Unity基础的开发者。如果您是初次接触Unity，我们建议您先完成Unity官方的入门教程，再回到本指南进行项目搭建。无论您是独立开发者还是团队成员，本指南都将为您提供专业级的项目初始化方案。

---

## 🚀 第一章：环境准备与验证

在开始创建项目之前，我们需要确保开发环境已经准备就绪。这一步骤看似简单，却至关重要。一个配置正确的开发环境能够避免后续90%的配置问题，节省大量排查和修复的时间。

### 1.1 Unity Hub 安装与配置

#### 步骤一：下载Unity Hub

打开浏览器，访问Unity官方网站（https://unity.com/cn/download）。在页面中找到Unity Hub的下载按钮，点击下载适合您操作系统的安装程序。Unity Hub是管理Unity版本和项目的核心工具，它允许您在同一台电脑上安装多个Unity版本，并且能够轻松切换，这对于维护不同项目非常有用。

下载完成后，运行安装程序，按照向导提示完成安装。安装过程通常不需要额外的配置，保持默认设置即可。安装完成后，首次启动Unity Hub时，您需要登录Unity账号。如果您还没有账号，可以在登录界面选择注册。Unity账号是免费的，它是您使用Unity生态系统各项服务的基础。

#### 步骤二：安装Unity 2022.3.62f2c1

在Unity Hub的左侧导航栏中，点击「安装」选项卡，然后点击右上角的「安装编辑器」按钮。这将打开版本选择界面。在版本列表中，找到并选择 **2022.3.62f2c1** 这个版本。请注意，这个版本号非常具体，选择时务必核对清楚，避免选择相似的版本。

点击「下一步」后，您将看到模块选择界面。对于Windows平台开发，我们至少需要勾选以下模块：首先是「Microsoft Visual Studio Community」，这是Windows平台推荐的代码编辑器；其次是「WebGL Build Support」，如果您计划将游戏发布到网页平台；最后是「Windows Build Support」，这是构建Windows可执行文件所必需的。

点击「安装」按钮开始下载和安装。这个过程可能需要一些时间，取决于您的网络速度。建议在网络稳定的环境下进行安装，避免中途断导致需要重新下载。安装完成后，您可以在「安装」列表中看到新安装的Unity版本。

#### 步骤三：验证安装

安装完成后，我们需要验证Unity是否正确安装。打开Unity Hub，在「安装」选项卡中找到刚安装的版本，点击它旁边的齿轮图标，选择「显示在资源管理器中」。这将打开安装目录，您可以确认文件结构是否完整。

回到Unity Hub，点击「新建」项目，在项目模板列表中应该能看到各种2D和3D模板。这表明Unity Editor已经正确安装。如果模板列表为空或有错误提示，您可能需要重新安装Unity Hub或检查系统权限。

### 1.2 Visual Studio 2022 安装与配置

#### 步骤一：下载Visual Studio 2022

虽然Unity自带了Mono Editor作为代码编辑器，但我们强烈建议使用Visual Studio 2022作为主要开发工具。Visual Studio提供了更强大的代码补全、重构工具、调试功能和项目管理能力，能够显著提升开发效率。

访问Visual Studio官方网站（https://visualstudio.microsoft.com/zh-hans/downloads/），下载Visual Studio 2022 Community版本。这是免费版本，功能足够满足个人开发者和小型团队的需求。下载完成后，运行安装程序。

#### 步骤二：选择工作负载

在Visual Studio安装向导中，您需要选择「工作负载」。对于Unity开发，我们建议勾选以下选项：

首先是「使用Unity的游戏开发」，这是核心的Unity开发工具集，它包含了Unity开发所需的所有组件；其次是「.NET桌面开发」，如果您计划使用C#进行一些工具开发或脚本编写；第三是「Web开发」，如果您需要开发相关的网页工具或API。

这些工作负载的安装可能需要额外的下载和安装时间。您可以点击「安装」按钮开始整个安装过程。

#### 步骤三：配置外部工具

安装完成后，打开Visual Studio 2022，熟悉一下界面布局。然后打开Unity Editor，在菜单栏中选择「Edit → Preferences → External Tools」。在「External Script Editor」下拉菜单中，选择「Visual Studio 2022」。

点击「Regenerate project files」按钮，这将为项目重新生成解决方案文件，确保Visual Studio能够正确识别Unity项目的结构。设置完成后，点击「OK」保存设置。

### 1.3 Git 与 GitHub 配置

#### 步骤一：安装Git

访问Git官方网站（https://git-scm.com/），下载适合您操作系统的Git版本。Git是目前最流行的分布式版本控制系统，它将贯穿整个项目的开发周期。下载完成后，运行安装程序。

在安装向导中，我们建议保持大多数默认设置，但以下几点需要注意：首先是「Adjusting your PATH environment」，建议选择「Git from the command line and also from 3rd-party software」，这样您可以在任何命令行工具中使用Git；其次是「Choosing the SSH executable」，如果您计划使用SSH方式连接GitHub，建议选择「Use the OpenSSH library」。

#### 步骤二：配置Git用户信息

打开命令行工具（Windows用户可以使用CMD、PowerShell或Windows Terminal，macOS用户使用Terminal），执行以下命令配置您的Git用户信息。这些信息将随每次提交保存，是代码溯源的重要依据。

```bash
git config --global user.name "您的用户名"
git config --global user.email "您的邮箱地址"
```

请使用与您的GitHub账号相同的邮箱地址，这样提交记录才能正确关联到您的GitHub账号。接下来，执行以下命令设置默认的文本编辑器，用于处理合并冲突和编写提交信息：

```bash
git config --global core.editor "code --wait"
```

这条命令将Visual Studio Code设置为默认编辑器。如果您使用其他编辑器，请相应修改。

#### 步骤三：创建GitHub仓库

访问GitHub网站（https://github.com/），登录您的账号。点击页面右上角的「+」图标，选择「New repository」。在「Repository name」字段中输入项目名称，我们建议使用「DayAndNight」作为仓库名称。

在「Description」字段中简要描述项目，例如「2D像素风格动作RPG + 肉鸽 + 养成游戏」。选择仓库可见性，对于开源项目可以选择「Public」，对于私有项目选择「Private」。勾选「Add a README file」选项，这将自动创建一个包含项目信息的README文件。

点击「Create repository」按钮，仓库就创建完成了。您将看到仓库页面，上面显示了一些初始信息，包括仓库的URL。这个URL将在后续步骤中使用。

#### 步骤四：生成SSH密钥（可选）

如果您计划使用SSH方式连接GitHub，建议生成SSH密钥来提高安全性。打开命令行工具，执行以下命令生成密钥：

```bash
ssh-keygen -t ed25519 -C "您的邮箱地址"
```

按照提示，选择密钥保存位置（可以直接按回车使用默认位置），并设置一个密码保护您的密钥。生成完成后，找到公钥文件（默认为~/.ssh/id_ed25519.pub），将其内容复制到GitHub的SSH密钥设置中。

### 1.4 辅助工具安装

#### 步骤一：Aseprite（像素画工具）

作为2D像素风格游戏，Aseprite是制作游戏美术资源的首选工具。访问Aseprite官方网站（https://www.aseprite.org/），下载适合您操作系统的版本。Aseprite是付费软件，但提供了完整的试用功能。如果您是独立开发者，可以考虑购买许可证支持开发者。

安装完成后，打开Aseprite，熟悉一下界面布局。主要区域包括：工具栏（左侧）、时间线（底部）、画布（中央）和颜色选择器（右侧）。创建一个简单的测试文件，尝试使用铅笔、橡皮擦和填充工具，为后续的美术资源制作做准备。

#### 步骤二：Tiled地图编辑器（可选）

如果您计划使用Tilemap系统制作游戏地图，Tiled是一个强大的工具选择。访问Tiled官方网站（https://www.mapeditor.org/），下载最新版本。Tiled是免费开源软件，可以自由使用。

安装完成后，打开Tiled，创建一个新地图。选择「Orthogonal」地图方向，设置地图大小（例如32x32瓦片）和瓦片大小（例如16x16像素或32x32像素）。保存地图文件到项目的适当位置，熟悉Tiled的界面和基本操作。

---

## 🏗️ 第二章：创建Unity项目

现在我们已经完成了所有准备工作，接下来开始创建Unity项目。这一步骤将建立游戏的核心工程结构，是整个项目的基础。一个正确初始化的项目能够避免后续的很多麻烦，包括资源管理、版本控制和团队协作等方面的问题。

### 2.1 使用Unity Hub创建项目

#### 步骤一：启动项目创建

打开Unity Hub，点击「新建项目」按钮。在项目创建界面，您需要选择项目模板。对于2D像素风格游戏，我们选择「2D Core」模板。这个模板已经预配置了2D开发所需的基本设置，包括2D相机、灯光和物理系统。

在「项目名称」字段中输入「DayAndNight」。在「位置」字段中，选择一个合适的文件夹来存放项目文件。我们建议使用简短的路径，避免使用空格和特殊字符。例如：`G:\GameDev\DayAndNight` 或 `/Users/username/Projects/DayAndNight`。

#### 步骤二：选择Unity版本

在项目创建界面的底部，找到「Editor Version」下拉菜单。选择我们之前安装的 **2022.3.62f2c1** 版本。确保版本号完全一致，因为不同版本的Unity可能在某些设置上存在差异，使用特定版本可以确保团队成员使用相同的环境。

#### 步骤三：高级项目设置

点击「Advanced Project Settings」（高级项目设置）展开更多选项。在「Scripting Backend」中，确保选择「IL2CPP」，这是Unity推荐的脚本后端，提供了更好的性能和安全性。在「Api Compatibility Level」中，选择「.NET Framework」以获得更完整的.NET功能支持。

如果您计划发布到多个平台，可以在这里勾选相应的平台支持。但为了简化初始设置，我们建议先只选择当前主要开发平台。

#### 步骤四：创建项目

确认所有设置正确后，点击「创建项目」按钮。Unity将开始初始化项目，这可能需要几分钟时间。首次创建时，Unity会生成大量的项目文件和设置，请耐心等待。项目创建完成后，Unity Editor将自动打开。

### 2.2 项目初始化配置

#### 步骤一：项目设置面板

Unity Editor启动后，首先打开项目设置面板。在菜单栏中选择「Edit → Project Settings」，或者使用快捷键「Ctrl+Shift+S」（Windows）或「Cmd+Shift+S」（macOS）。项目设置面板包含了游戏运行时的所有配置选项。

在左侧的设置列表中，我们逐项进行配置：

**Player设置（最重要的设置）：**
- 点击「Player」选项卡，展开「Resolution and Presentation」部分
- 在「Default Screen Width」和「Default Screen Height」中输入适合的值，例如960x540（16:9比例）
- 在「Run In Background」选项中勾选，确保游戏在失去焦点时继续运行
- 在「Allow HDR Display」中取消勾选（对于像素风格游戏，通常不需要HDR）

- 展开「Other Settings」部分
- 在「Color Space」中选择「Gamma」而不是「Linear」（像素风格游戏使用Gamma色彩空间更合适）
- 在「Active Input Handling」中选择「Both」或「Input System Package (New)」，建议使用新的输入系统

**Physics设置：**
- 点击「Physics」选项卡
- 设置「Default Gravity」的值为（0, -980, 0），这为2D物理提供了更自然的感觉
- 调整「Default Solver Iterations」为适当的值（通常6-8即可）

**Quality设置：**
- 点击「Quality」选项卡
- 删除不需要的质量级别，保留3-4个级别即可
- 将「Default」设置为较低的质量级别，以获得更好的性能

#### 步骤二：标签和图层配置

在项目设置面板中，点击「Tags and Layers」选项卡。我们需要为游戏添加自定义的图层和标签，用于物理检测、渲染排序和碰撞检测。

**添加图层（Layers）：**
点击「Layers」下拉框，选择「Edit Layers」。在空白图层槽中，按顺序添加以下图层：

1. Player - 玩家对象所在的图层
2. Enemy - 敌人对象所在的图层
3. NPC - NPC对象所在的图层
4. Interactable - 可交互物体所在的图层
5. Water - 水面等特殊地形
6. TransparentFX - 透明特效
7. Ignore Raycast - 忽略射线检测

**添加标签（Tags）：**
点击「Tags」下拉框，选择「Add Tag」。添加以下标签：

1. Player - 玩家
2. Enemy - 敌人
3. NPC - 非玩家角色
4. Item - 物品
5. Interactable - 可交互物体
6. Projectile - 投射物
7. Ground - 地面
8. Wall - 墙壁

这些图层和标签将在后续的脚本开发中广泛使用，务必在项目初期就建立好规范。

#### 步骤三：时间与音频设置

在项目设置面板中，点击「Time」选项卡。设置「Fixed Timestep」为0.02（每秒50次物理更新），这对于动作游戏来说是一个平衡性能和精度的值。如果您的游戏对物理精度有更高要求，可以设置为0.0167（每秒60次）。

在「Maximum Particle Timestep」中输入0.05，确保粒子系统在低帧率情况下也不会过度占用CPU资源。

点击「Audio」选项卡，在「Default Speaker Mode」中选择「Stereo」（立体声），对于大多数游戏来说已经足够。如果您正在开发需要环绕声效果的游戏，可以选择相应的环绕声模式。

### 2.3 导入必要包

#### 步骤一：打开Package Manager

在菜单栏中选择「Window → Package Manager」，或者使用快捷键「Ctrl+Shift+B」（Windows）或「Cmd+Shift+B」（macOS）。Package Manager是Unity管理扩展包的核心工具。

在Package Manager的左上角，点击「+」图标，选择「Add package from git URL」。我们将添加几个重要的包来增强Unity的功能。

#### 步骤二：安装Input System包

在输入框中输入以下URL：

```
https://github.com/Unity-Technologies/InputSystem.git?path=Packages/com.unity.inputsystem
```

点击「Add」按钮开始安装。这个包提供了新的输入系统，支持多种输入设备（键盘、鼠标、手柄、触摸等），并且配置更加灵活。安装完成后，Unity可能会提示您重启编辑器以完成集成。

#### 步骤三：安装Addressables包（推荐）

Addressables是Unity的资源管理系统，它提供了按需加载、动态更新和资源打包的功能。对于中大型游戏来说，这是非常重要的工具。

在输入框中输入以下URL：

```
https://github.com/Unity-Technologies/Addressables.git?path=Packages/com.unity.addressables
```

点击「Add」按钮开始安装。安装完成后，您可以在菜单栏中看到新增的「Window → Asset Management → Addressables」菜单项。

#### 步骤四：安装其他推荐包

根据项目需要，您还可以安装以下包：

**TextMeshPro（通常已预装）：**
用于高质量的文本渲染。在Package Manager中搜索「TextMeshPro」，如果未安装，点击「Install」按钮。

**2D Sprite Shape（用于2D游戏）：**
在Package Manager中搜索「2D Sprite Shape」，安装此包以获得更灵活的2D图形工具。

---

## 📁 第三章：项目目录结构创建

项目目录结构是整个项目的骨架，一个好的目录结构能够大大提高开发效率，降低维护成本。我们将使用终端命令来创建目录结构，这是一种高效、可重复且易于记录的方法。

### 3.1 打开终端并定位项目目录

#### 步骤一：打开终端

**Windows用户：**
- 按下「Win + R」键，输入「powershell」，点击「确定」
- 或者右键点击「开始」菜单，选择「Windows PowerShell」

**macOS用户：**
- 按下「Command + Space」，输入「Terminal」，按回车
- 或者在「应用程序 → 实用工具」中找到「终端」

#### 步骤二：定位到项目目录

在终端中，使用 `cd` 命令切换到Unity项目的目录。假设您的项目位于 `G:\GameDev\DayAndNight`，请执行：

**Windows (PowerShell)：**
```powershell
cd G:\GameDev\DayAndNight
```

**macOS/Linux：**
```bash
cd /Users/yourusername/Projects/DayAndNight
```

执行 `pwd`（macOS/Linux）或 `cd`（Windows）命令确认当前位置。

### 3.2 创建核心目录结构

#### 步骤一：创建项目资源主目录

在项目根目录下执行以下命令，创建完整的目录结构。这些目录将包含所有的游戏资源、脚本、配置和第三方库。

**Windows (PowerShell)：**
```powershell
# 创建Assets下的_Project目录结构
mkdir -p "Assets/_Project/Scripts/Core"
mkdir -p "Assets/_Project/Scripts/Gameplay"
mkdir -p "Assets/_Project/Scripts/UI"
mkdir -p "Assets/_Project/Scripts/Data"
mkdir -p "Assets/_Project/Scripts/Utilities"
mkdir -p "Assets/_Project/Scenes/Main"
mkdir -p "Assets/_Project/Scenes/Town"
mkdir -p "Assets/_Project/Scenes/Combat"
mkdir -p "Assets/_Project/Scenes/Interior"
mkdir -p "Assets/_Project/Scenes/Special"
mkdir -p "Assets/_Project/Prefabs/Characters"
mkdir -p "Assets/_Project/Prefabs/Items"
mkdir -p "Assets/_Project/Prefabs/UI"
mkdir -p "Assets/_Project/Prefabs/Environment"
mkdir -p "Assets/_Project/Prefabs/Effects"
mkdir -p "Assets/_Project/Prefabs/Interactables"
mkdir -p "Assets/_Project/Art/Sprites/Characters"
mkdir -p "Assets/_Project/Art/Sprites/Items"
mkdir -p "Assets/_Project/Art/Sprites/Environment"
mkdir -p "Assets/_Project/Art/Sprites/UI"
mkdir -p "Assets/_Project/Art/Sprites/Tilesets"
mkdir -p "Assets/_Project/Art/Animations/Characters"
mkdir -p "Assets/_Project/Art/Animations/Effects"
mkdir -p "Assets/_Project/Art/Materials"
mkdir -p "Assets/_Project/Art/Shaders"
mkdir -p "Assets/_Project/Audio/Music"
mkdir -p "Assets/_Project/Audio/SFX"
mkdir -p "Assets/_Project/Audio/Ambient"
mkdir -p "Assets/_Project/Audio/Voice"
mkdir -p "Assets/_Project/Data/Config"
mkdir -p "Assets/_Project/Data/Dialogues"
mkdir -p "Assets/_Project/Data/Localization"
mkdir -p "Assets/_Project/Data/Database"
mkdir -p "Assets/_Project/Resources/Dynamic"
mkdir -p "Assets/_Project/Resources/UI"
mkdir -p "Assets/_Project/Resources/Prefabs"
mkdir -p "Assets/Plugins/Editor"
mkdir -p "Assets/Plugins/Runtime"
mkdir -p "Assets/Settings"
```

**macOS/Linux：**
```bash
# 创建Assets下的_Project目录结构
mkdir -p "Assets/_Project/Scripts/Core"
mkdir -p "Assets/_Project/Scripts/Gameplay"
mkdir -p "Assets/_Project/Scripts/UI"
mkdir -p "Assets/_Project/Scripts/Data"
mkdir -p "Assets/_Project/Scripts/Utilities"
mkdir -p "Assets/_Project/Scenes/Main"
mkdir -p "Assets/_Project/Scenes/Town"
mkdir -p "Assets/_Project/Scenes/Combat"
mkdir -p "Assets/_Project/Scenes/Interior"
mkdir -p "Assets/_Project/Scenes/Special"
mkdir -p "Assets/_Project/Prefabs/Characters"
mkdir -p "Assets/_Project/Prefabs/Items"
mkdir -p "Assets/_Project/Prefabs/UI"
mkdir -p "Assets/_Project/Prefabs/Environment"
mkdir -p "Assets/_Project/Prefabs/Effects"
mkdir -p "Assets/_Project/Prefabs/Interactables"
mkdir -p "Assets/_Project/Art/Sprites/Characters"
mkdir -p "Assets/_Project/Art/Sprites/Items"
mkdir -p "Assets/_Project/Art/Sprites/Environment"
mkdir -p "Assets/_Project/Art/Sprites/UI"
mkdir -p "Assets/_Project/Art/Sprites/Tilesets"
mkdir -p "Assets/_Project/Art/Animations/Characters"
mkdir -p "Assets/_Project/Art/Animations/Effects"
mkdir -p "Assets/_Project/Art/Materials"
mkdir -p "Assets/_Project/Art/Shaders"
mkdir -p "Assets/_Project/Audio/Music"
mkdir -p "Assets/_Project/Audio/SFX"
mkdir -p "Assets/_Project/Audio/Ambient"
mkdir -p "Assets/_Project/Audio/Voice"
mkdir -p "Assets/_Project/Data/Config"
mkdir -p "Assets/_Project/Data/Dialogues"
mkdir -p "Assets/_Project/Data/Localization"
mkdir -p "Assets/_Project/Data/Database"
mkdir -p "Assets/_Project/Resources/Dynamic"
mkdir -p "Assets/_Project/Resources/UI"
mkdir -p "Assets/_Project/Resources/Prefabs"
mkdir -p "Assets/Plugins/Editor"
mkdir -p "Assets/Plugins/Runtime"
mkdir -p "Assets/Settings"
```

#### 步骤二：创建项目根目录的配置文件

在项目根目录（与Assets同级的目录），执行以下命令创建必要的配置文件和文档目录：

**Windows (PowerShell)：**
```powershell
# 创建文档目录
mkdir -p "Docs"
mkdir -p "Tools"
mkdir -p "Builds"
mkdir -p "Exports"

# 创建项目配置文件
New-Item -ItemType File -Name ".gitignore" -Path "."
New-Item -ItemType File -Name ".gitattributes" -Path "."
New-Item -ItemType File -Name "CHANGELOG.md" -Path "."
New-Item -ItemType File -Name "CONTRIBUTING.md" -Path "."
```

**macOS/Linux：**
```bash
# 创建文档目录
mkdir -p "Docs"
mkdir -p "Tools"
mkdir -p "Builds"
mkdir -p "Exports"

# 创建项目配置文件
touch ".gitignore"
touch ".gitattributes"
touch "CHANGELOG.md"
touch "CONTRIBUTING.md"
```

### 3.3 配置Git忽略文件

#### 步骤一：编写.gitignore文件

`.gitignore`文件告诉Git哪些文件应该忽略，不纳入版本控制。对于Unity项目，有一些文件是必须忽略的，因为它们是自动生成的或者包含敏感信息。

打开项目根目录下的`.gitignore`文件，添加以下内容：

```gitignore
# Unity generated
[Ll]ibrary/
[Tt]emp/
[Oo]bj/
[Bb]uild/
[Bb]uilds/
[Ll]ogs/
[Uu]pdated/

# Autogenerated VS/MD/Consulo solution and project files
*.csproj
*.unityproj
*.sln
*.suo
*.tmp
*.user
*.userprefs
*.pidb
*.booproj
*.svd
*.pdb
*.opendb

# Visual Studio cache files
.vs/

# Rider
.idea/

# OS generated
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
*.log
*.txt

# Build
*.apk
*.aab
*.unitypackage
*.app

# Test
[Tt]est[Rr]esults/

# Package
*.unitypackage.meta
```

#### 步骤二：创建.gitattributes文件

`.gitattributes`文件用于配置Git的属性，例如文件的换行符处理等。

打开项目根目录下的`.gitattributes`文件，添加以下内容：

```gitattributes
# Auto detect text files and perform LF normalization
* text=auto

# Unity YAML files
*.yaml text
*.yml text
*.mat text
*.prefab text
*.scene text

# C# files
*.cs text
*.csproj text

# Text files
*.md text
*.txt text
*.json text
*.xml text
*.csv text

# Set default behavior
* text=auto eol=lf

# Explicitly declare text files you want to always be normalized
# If text files are detected incorrectly, add here
# *.cpp text
# *.h text
```

### 3.4 初始化Git仓库并连接远程

#### 步骤一：初始化本地仓库

在终端中，确保当前目录是项目根目录，执行以下命令初始化Git仓库：

```bash
git init
```

执行 `git status` 命令，您应该看到项目文件处于未跟踪状态。

#### 步骤二：创建初始提交

执行以下命令，将所有文件添加到暂存区并创建初始提交：

```bash
git add .
git commit -m "chore: 初始化项目结构和目录"
```

#### 步骤三：添加远程仓库

执行以下命令，将本地仓库连接到GitHub远程仓库（请将URL替换为您的实际仓库URL）：

```bash
git remote add origin https://github.com/您的用户名/DayAndNight.git
```

执行 `git remote -v` 命令验证远程仓库配置是否正确。

#### 步骤四：推送到远程仓库

执行以下命令，将本地提交推送到GitHub：

```bash
git branch -M main
git push -u origin main
```

现在，您可以在GitHub仓库页面看到所有项目文件了。

### 3.5 创建Unity.meta文件

Unity使用.meta文件来跟踪资源的设置和引用。这些文件通常在Unity编辑器中操作资源时自动生成。但有时需要手动创建或同步。

在Unity Editor中，打开项目后，所有.meta文件应该会自动生成。您可以通过以下方式验证：

1. 在Project窗口中，确保显示.meta文件（点击右上角的「三个点」菜单，选择「Show Meta Files」）
2. 检查每个目录和资源文件旁边是否都有对应的.meta文件
3. 如果缺少.meta文件，可以在Unity Editor中选中该资源，点击「Reimport」强制重新导入

---

## ⚙️ 第四章：核心系统初始化

项目结构创建完成后，我们需要初始化核心系统。这些系统将作为游戏的基础架构，支撑所有上层功能的开发。我们将创建基础的脚本框架、预制体和场景设置。

### 4.1 创建核心管理器脚本

#### 步骤一：创建GameManager

在Unity Editor中，在Project窗口中导航到 `Assets/_Project/Scripts/Core` 目录。右键点击空白区域，选择「Create → C# Script」，创建一个名为 `GameManager` 的脚本。

GameManager是游戏的核心管理器，负责协调所有子系统的初始化和管理游戏的生命周期。以下是GameManager的主要职责：

- **游戏状态管理**：维护游戏当前的状态（开始、运行、暂停、结束）
- **系统协调**：在启动时初始化各个管理器
- **场景管理**：处理场景加载和卸载
- **全局访问点**：提供访问各个管理器的单例接口

#### 步骤二：创建Managers脚本文件夹结构

按照以下结构，在 `Assets/_Project/Scripts/Core` 目录下创建基础管理器脚本：

**必需的核心管理器：**
1. `GameManager` - 游戏主管理器
2. `TimeManager` - 时间管理系统
3. `EventManager` - 事件系统
4. `AudioManager` - 音频系统
5. `SaveManager` - 存档系统
6. `DataManager` - 数据管理系统
7. `UIManager` - UI管理系统

**核心接口（定义管理器的标准方法）：**
1. `IManager` - 所有管理器的基础接口
2. `ISaveable` - 可存档数据的接口

#### 步骤三：创建基础脚本模板

为每个管理器创建基础的空脚本模板。模板应该包含：

- 正确的命名空间结构
- 单例模式的实现
- 基础的Awake/Start/Update方法
- 初始化和清理方法

### 4.2 创建游戏对象预制体

#### 步骤一：创建GameManagers预制体

1. 在Hierarchy窗口中，右键点击空白区域，选择「Create Empty」，命名为「GameManagers」
2. 创建以下空GameObject作为子对象：
   - EventSystem（用于事件管理）
   - AudioSystem（用于音频管理）
   - SaveSystem（用于存档管理）
   - DataSystem（用于数据管理）
3. 将「GameManagers」对象拖到 `Assets/_Project/Prefabs/Environment` 目录中，创建一个预制体
4. 从Hierarchy中删除这个对象（在场景中保留会干扰开发）

#### 步骤二：创建Managers脚本挂载

在Project窗口中，导航到 `Assets/_Project/Prefabs/Environment` 目录，双击打开预制体进行编辑。在每个子对象上挂载相应的脚本组件：

- EventSystem → EventManager脚本
- AudioSystem → AudioManager脚本
- SaveSystem → SaveManager脚本
- DataSystem → DataManager脚本

### 4.3 设置主场景

#### 步骤一：创建主场景

1. 在菜单栏中选择「File → New Scene」
2. 选择「Basic (Built-in)」模板
3. 保存到 `Assets/_Project/Scenes/Main` 目录，命名为「Main.unity」
4. 关闭场景（File → Close Scene）

#### 步骤二：创建游戏主场景

1. 再次创建新场景
2. 保存到 `Assets/_Project/Scenes/Town` 目录，命名为「Town.unity」
3. 这个场景将作为游戏的主要活动区域
4. 关闭场景

#### 步骤三：创建场景加载器

1. 创建一个名为 `SceneLoader` 的脚本
2. 实现异步场景加载功能
3. 添加加载进度显示功能
4. 实现场景切换过渡效果

### 4.4 创建全局资源

#### 步骤一：创建游戏配置ScriptableObject

1. 在 `Assets/_Project/Data/Config` 目录下，创建 `GameConfig` ScriptableObject
2. 包含以下配置项：
   - 游戏版本号
   - 默认语言设置
   - 目标帧率
   - 默认难度设置
   - 时间流速
   - 自动保存间隔

#### 步骤二：创建标签常量类

1. 创建一个 `GameTags` 静态类
2. 定义所有游戏标签的字符串常量
3. 便于代码维护和避免拼写错误

#### 步骤三：创建图层常量类

1. 创建一个 `GameLayers` 静态类
2. 定义所有图层的整数常量
3. 提供图层名称到整数值的转换方法

---

## 🏷️ 第五章：编码规范与工作流

良好的编码规范是大型项目成功的关键。在这一章节中，我们将建立一套完整的编码规范和开发工作流，确保团队成员能够写出风格一致的代码。

### 5.1 命名规范

#### 步骤一：类命名规范

**规则：** 使用PascalCase命名法，首字母大写

- 核心管理器使用「Manager」后缀：`GameManager`、`TimeManager`、`AudioManager`
- 基类使用「Base」后缀：`BaseManager`、`BaseItem`、`BaseEnemy`
- 接口使用「I」前缀：`IManager`、`ISaveable`、`IDamageable`
- 组件使用「Controller」或「Handler」后缀：`PlayerController`、`InventoryHandler`

**示例代码：**
```csharp
// 正确示例
public class GameManager : MonoBehaviour { }
public interface IManager { }
public abstract class BaseEnemy : MonoBehaviour { }

// 错误示例
public class gameManager : MonoBehaviour { }
public class manager_game : MonoBehaviour { }
```

#### 步骤二：方法命名规范

**规则：** 使用PascalCase命名法，首字母大写

- 公共方法：描述性强，明确表达方法功能
- 私有方法：使用动词开头，可以加下划线前缀（团队约定）

**示例代码：**
```csharp
// 正确示例
public void InitializeGame() { }
public bool LoadPlayerData(string savePath) { }
public IEnumerator LoadSceneAsync(string sceneName) { }

// 内部使用下划线前缀（团队约定）
private void _InitializeManagers() { }
private bool _LoadDataFromFile(string path) { }
```

#### 步骤三：变量命名规范

**规则：** 使用camelCase命名法，首字母小写

- 公共变量：明确描述变量含义
- 私有字段：使用「_」前缀（推荐）
- 常量：使用UPPER_CASE命名法

**示例代码：**
```csharp
// 正确示例
public int playerHealth;
public float movementSpeed;
private int _currentLevel;
private bool _isInitialized;
private const float MAX_HEALTH = 100f;

// 错误示例
public int PH;  // 不清晰
public float MvSpd;  // 缩写不推荐
private int currentlevel;  // 不一致的命名
```

#### 步骤四：命名空间规范

**规则：** 使用公司/团队名.游戏模块.功能模块的结构

**示例代码：**
```csharp
namespace DayAndNight.Core
{
    namespace Managers { }
    namespace Utilities { }
}

namespace DayAndNight.Gameplay
{
    namespace Combat { }
    namespace Attributes { }
    namespace Quests { }
}

namespace DayAndNight.UI
{
    namespace HUD { }
    namespace Menus { }
    namespace Dialogs { }
}
```

### 5.2 注释规范

#### 步骤一：XML文档注释

**规则：** 所有公共类和方法必须添加XML文档注释

**示例代码：**
```csharp
/// <summary>
/// 游戏主管理器，负责协调所有子系统和游戏生命周期管理
/// </summary>
public class GameManager : MonoBehaviour
{
    /// <summary>
    /// 初始化所有管理器系统
    /// </summary>
    /// <returns>初始化是否成功</returns>
    public bool Initialize() { }
    
    /// <summary>
    /// 暂停或恢复游戏
    /// </summary>
    /// <param name="pause">是否暂停</param>
    public void SetPause(bool pause) { }
}
```

#### 步骤二：代码内注释

**规则：** 复杂的逻辑必须添加注释说明

**示例代码：**
```csharp
/// <summary>
/// 计算最终伤害值
/// </summary>
/// <param name="attack">基础攻击力</param>
/// <param name="defense">目标防御力</param>
/// <returns>最终伤害值</returns>
public int CalculateDamage(int attack, int defense)
{
    // 基础伤害 = 攻击力 - 防御力
    int baseDamage = attack - defense;
    
    // 确保最小伤害为1，避免无敌情况
    baseDamage = Mathf.Max(1, baseDamage);
    
    // 暴击判定（15%基础暴击率）
    bool isCritical = Random.value <= 0.15f;
    if (isCritical)
    {
        baseDamage = Mathf.RoundToInt(baseDamage * 1.5f);
    }
    
    return baseDamage;
}
```

#### 步骤三：TODO注释

**规则：** 使用TODO注释标记待完成的工作

**示例代码：**
```csharp
// TODO: 待实现敌人AI行为
// TODO: [High Priority] 修复装备穿戴的边界情况
// TODO: [Optimization] 优化对象池的初始化逻辑
```

### 5.3 Git工作流

#### 步骤一：分支策略

我们采用Git Flow的简化版本作为分支策略：

- **main分支**：稳定版本，只接受发布或热修复
- **develop分支**：开发主分支，所有功能合并到这里
- **feature/xxx分支**：功能开发分支，从develop分支创建
- **hotfix/xxx分支**：紧急修复分支，从main分支创建

#### 步骤二：提交规范

**格式：** `<type>: <subject>`

**类型（Type）：**
- `feat`：新功能
- `fix`：修复bug
- `docs`：文档更新
- `style`：代码格式调整
- `refactor`：代码重构
- `perf`：性能优化
- `test`：测试相关
- `chore`：构建/工具相关
- `ci`：CI/CD相关

**示例提交：**
```
feat: 添加玩家移动和跳跃功能
fix: 修复装备栏的物品堆叠问题
docs: 更新README中的安装说明
refactor: 重构事件系统，改为泛型实现
```

#### 步骤三：代码审查流程

1. 在功能分支完成开发后，创建Pull Request
2. 至少需要一名团队成员审查代码
3. 所有检查通过后才能合并到develop分支
4. 合并后删除功能分支

### 5.4 代码质量检查

#### 步骤一：设置Unity代码规范

在Unity Editor中，选择「Edit → Preferences → External Tools → Code Formatting」，确保以下设置：

- 缩进大小：4个空格
- 行尾模式：根据操作系统自动处理
- 编码：UTF-8

#### 步骤二：使用Unity的静态分析

Unity内置了代码分析功能，会在编译时检测常见问题。确保所有警告都得到处理，不要忽略警告信息。

#### 步骤三：定期代码重构

建议每周安排一次代码审查时间，处理技术债务：

- 识别重复代码，提取公共方法
- 优化性能瓶颈
- 更新过时代码
- 完善单元测试

---

## 🔧 第六章：开发工具与调试配置

良好的开发工具配置能够大大提高开发效率。在这一章节中，我们将配置各种开发工具和调试功能。

### 6.1 Unity编辑器优化

#### 步骤一：调整编辑器布局

1. 在菜单栏中选择「Window → Layouts → Save Layout」
2. 创建名为「Development」的布局，包含：
   - Project窗口（左侧）
   - Hierarchy窗口（左侧）
   - Inspector窗口（右侧）
   - Console窗口（底部）
   - Game窗口（中央）
3. 保存布局并设置为默认

#### 步骤二：配置项目视图

1. 在Project窗口中，点击右上角的搜索框旁的图标
2. 选择「Customize Columns」
3. 添加以下列：
   - Name（名称）
   - Type（类型）
   - Label（标签）
   - Modified（修改时间）
4. 调整列宽以显示完整信息

#### 步骤三：设置默认脚本模板

在 `Assets/Scripts/Editor` 目录下创建脚本模板文件，命名为 `C# Script-NewScript.cs.txt`。文件内容如下：

```csharp
/// <summary>
/// [在此描述脚本功能]
/// </summary>
public class #SCRIPTNAME# : MonoBehaviour
{
    #region 私有变量
    #endregion

    #region 生命周期
    private void Awake() { }
    private void Start() { }
    private void Update() { }
    private void FixedUpdate() { }
    private void LateUpdate() { }
    #endregion

    #region 公共方法
    #endregion

    #region 私有方法
    #endregion
}
```

### 6.2 控制台配置

#### 步骤一：启用详细日志

在开发期间，启用详细的日志输出：

1. 选择「Edit → Project Settings → Player」
2. 在「Other Settings」中，找到「Log」设置
3. 勾选「Log When Using Stack Trace」
4. 设置「Stack Trace Limit」为适当的值（如5）

#### 步骤二：创建自定义日志工具

创建一个 `Debug` 工具类，提供不同级别的日志方法：

```csharp
public static class GameDebug
{
    [System.Diagnostics.Conditional("UNITY_EDITOR")]
    public static void Log(object message) { }
    
    [System.Diagnostics.Conditional("UNITY_EDITOR")]
    public static void LogWarning(object message) { }
    
    [System.Diagnostics.Conditional("UNITY_EDITOR")]
    public static void LogError(object message) { }
    
    public static void LogFormatted(object message, params object[] args) { }
}
```

#### 步骤三：配置日志文件输出

在游戏发布版本中，将日志输出到文件：

```csharp
private void SetupFileLogging()
{
    string logPath = Path.Combine(Application.persistentDataPath, "logs");
    if (!Directory.Exists(logPath)) Directory.CreateDirectory(logPath);
    
    string logFile = Path.Combine(logPath, $"game_{DateTime.Now:yyyyMMdd_HHmmss}.log");
    Application.logMessageReceived += HandleLog;
}
```

### 6.3 开发者控制台

#### 步骤一：创建开发者控制台UI

1. 创建一个Canvas，设置为Screen Space - Overlay模式
2. 添加一个全屏的半透明Panel作为背景
3. 添加一个Input Field用于输入命令
4. 添加一个Scroll View用于显示命令输出
5. 将UI元素组织在 `Assets/_Project/Prefabs/UI/DevConsole` 预制体中

#### 步骤二：实现控制台核心功能

创建 `DevConsole` 脚本，实现以下功能：

- 命令解析和执行
- 命令历史（上下键切换）
- 自动补全
- 输出重定向

#### 步骤三：添加常用命令

实现以下常用调试命令：

```csharp
// 常用调试命令
/god           // 无敌模式
/additem [id] [count]  // 添加物品
/setattr [type] [level] // 设置属性
/time [hour]          // 设置时间
/spawn [enemyId]      // 生成敌人
/tp [location]        // 传送
/quest [questId]      // 完成任务
/stats                // 显示玩家状态
/clear                // 清屏
/help                 // 显示帮助
```

### 6.4 性能监控工具

#### 步骤一：创建FPS计数器

创建一个简单的FPS计数器脚本：

```csharp
public class FPSCounter : MonoBehaviour
{
    public Text fpsText;
    private float updateInterval = 0.5f;
    private float timer;
    private int frames;
    private float fps;
    
    private void Update()
    {
        timer += Time.unscaledDeltaTime;
        frames++;
        
        if (timer >= updateInterval)
        {
            fps = frames / timer;
            fpsText.text = $"FPS: {fps:F1}";
            timer = 0;
            frames = 0;
        }
    }
}
```

#### 步骤二：创建性能分析面板

创建一个性能分析面板，显示以下信息：

- 当前FPS
- 内存使用量
- 场景中的对象数量
- 绘制调用数量
- 粒子系统数量

#### 步骤三：集成Unity Profiler

在Unity Editor中，选择「Window → Analysis → Profiler」，打开Profiler窗口。在开发过程中定期检查性能数据，识别和解决性能瓶颈。

### 6.5 作弊与测试工具

#### 步骤一：创建测试模式

在游戏中添加测试模式的开关：

```csharp
public class TestModeManager : MonoBehaviour
{
    public static bool IsTestMode { get; private set; }
    
    [MenuItem("Tools/Test Mode/Enable Test Mode")]
    public static void EnableTestMode()
    {
        IsTestMode = true;
    }
    
    [MenuItem("Tools/Test Mode/Disable Test Mode")]
    public static void DisableTestMode()
    {
        IsTestMode = false;
    }
}
```

#### 步骤二：创建测试物品生成器

创建一个测试物品生成器UI，用于快速生成测试物品：

- 列出所有物品
- 一键添加物品
- 快速切换装备
- 重置玩家状态

#### 步骤三：创建场景测试工具

创建一个场景测试工具，用于：

- 快速切换场景
- 跳转到指定位置
- 生成测试敌人
- 模拟各种游戏状态

---

## 📦 第七章：第三方资源整合

在大型游戏开发中，合理使用第三方资源可以大大提高开发效率。在这一章节，我们将介绍如何整合各种第三方工具和资源。

### 7.1 JSON 对话系统（内置免费方案）

我们选择使用 **JSON 文件**来管理游戏对话，这是一个完全免费、灵活且易于维护的方案。

#### 方案特点

- ✅ **完全免费**：无需购买任何许可证
- ✅ **易于编辑**：使用任意文本编辑器或 JSON 编辑器
- ✅ **版本控制友好**：文本格式便于 Git 协作
- ✅ **灵活定制**：支持复杂分支、条件判断、变量系统
- ✅ **无需外部依赖**：纯 C# 实现，无第三方库依赖

#### 对话文件结构

对话文件保存在 `Assets/_Project/Data/Dialogues/` 目录下，格式为 `.json`：

```json
{
  "version": "1.0",
  "name": "对话名称",
  "description": "对话描述",
  "startNode": "起始节点ID",
  "tags": ["标签1", "标签2"],
  "nodes": [
    {
      "id": "节点ID",
      "speaker": "说话者名称",
      "text": "对话内容",
      "portrait": "头像路径",
      "nextNode": "下一个节点ID",
      "options": [],
      "condition": "$gold >= 50",
      "onEnterEvent": "触发事件名",
      "onExitEvent": "离开事件名"
    }
  ]
}
```

#### 核心脚本

1. **DialogueModels.cs** - 数据模型类
   - 路径：`Assets/_Project/Scripts/Data/Dialogue/DialogueModels.cs`
   - 定义对话数据结构

2. **DialogueManager.cs** - 对话管理器
   - 路径：`Assets/_Project/Scripts/Core/DialogueManager.cs`
   - 负责加载和管理对话

3. **DialogueUI.cs** - 对话界面
   - 路径：`Assets/_Project/Scripts/UI/DialogueUI.cs`
   - 管理对话的图形显示

#### 快速开始

```csharp
// 开始对话
DialogueManager.Instance.StartDialogue("对话文件名");

// 监听对话事件
DialogueManager.Instance.OnDialogueEnd += (args) => {
    GameDebug.Log("对话结束！");
};

// 获取当前状态
string speaker = DialogueManager.Instance.CurrentSpeaker;
string text = DialogueManager.Instance.CurrentText;
```

#### 条件表达式

支持以下条件判断语法：

| 语法 | 说明 | 示例 |
|------|------|------|
| `$变量 == 值` | 等于 | `$gold == 100` |
| `$变量 != 值` | 不等于 | `$completed != 1` |
| `$变量 > 值` | 大于 | `$level > 5` |
| `$变量 >= 值` | 大于等于 | `$reputation >= 50` |
| `$变量 < 值` | 小于 | `$health < 10` |
| `$变量 <= 值` | 小于等于 | `$time <= 60` |

#### 事件系统

支持在对话节点触发自定义事件：

| 事件格式 | 说明 | 示例 |
|---------|------|------|
| `GiveGold:数值` | 给予金币 | `GiveGold:100` |
| `SetFlag:标记名` | 设置标记 | `SetFlag:met_villager` |
| `GiveItem:物品ID` | 给予物品 | `GiveItem:iron_sword` |
| `AddQuest:任务ID` | 添加任务 | `AddQuest:wolf_hunting` |

#### 示例对话文件

已创建以下示例对话：

- **tutorial.json** - 新手引导对话
  - 路径：`Assets/_Project/Data/Dialogues/tutorial.json`
  - 功能：介绍游戏基本玩法

- **blacksmith.json** - 铁匠铺对话
  - 路径：`Assets/_Project/Data/Dialogues/blacksmith.json`
  - 功能：商店购买、任务系统集成

### 7.2 Aseprite 集成

#### 步骤一：创建导入设置

1. 在Project Settings中，找到「Aseprite」设置
2. 设置Aseprite可执行文件路径
3. 配置导入选项：
   - 生成精灵图集
   - 生成动画片段
   - 导入调色板

#### 步骤二：创建导入后处理脚本

创建自定义的导入后处理脚本，实现：

- 自动将Aseprite动画转换为Unity动画
- 自动生成精灵图集
- 自动创建动画控制器

#### 步骤三：创建精灵资源管理工具

创建一个工具面板，用于：

- 预览Aseprite动画
- 批量重新导入
- 调整导入设置

### 7.3 Addressables 配置

#### 步骤一：初始化Addressables

1. 选择「Window → Asset Management → Addressables → Groups」
2. 点击「Create Addressables Settings」
3. 选择资源打包模式：
   - 动态加载（推荐用于大项目）
   - 静态加载（简单项目）

#### 步骤二：创建标签系统

使用Addressables的标签系统组织资源：

```csharp
// 预定义标签
public static class AssetTags
{
    public const string PLAYER = "player";
    public const string ENEMY = "enemy";
    public const string NPC = "npc";
    public const string ITEM = "item";
    public const string LOCATION = "location";
    
    // 按场景分类
    public const string TOWN_SCENE = "scene_town";
    public const string COMBAT_SCENE = "scene_combat";
    
    // 按类型分类
    public const string SPRITE_32X32 = "sprite_32x32";
    public const string SPRITE_64X64 = "sprite_64x64";
}
```

#### 步骤三：创建资源加载器

创建统一的资源加载接口：

```csharp
public interface IResourceLoader
{
    T LoadAsset<T>(string address);
    void LoadAssetAsync<T>(string address, Action<T> onComplete);
    void ReleaseAsset(string address);
}
```

### 7.4 FMOD/音频管理

#### 步骤一：选择音频工具

根据项目需求选择：

**简单项目：** 使用Unity内置音频系统
**复杂项目：** 推荐使用FMOD或Wwise

#### 步骤二：音频组织结构

在 `Assets/_Project/Audio` 目录中组织音频资源：

```
Audio/
├── Music/          # 背景音乐
│   ├── Town/
│   ├── Combat/
│   ├── Night/
│   └── Boss/
├── SFX/            # 音效
│   ├── UI/
│   ├── Combat/
│   ├── Movement/
│   └── Environment/
├── Ambient/        # 环境音
│   ├── Weather/
│   └── Nature/
└── Voice/          # 语音
    ├── Dialogue/
    └── Narration/
```

#### 步骤三：创建音频管理器

创建 `AudioManager` 脚本，实现：

- 音乐播放管理
- 音效播放管理
- 音量控制
- 音频淡入淡出
- 空间音频支持

---

## 🔄 第八章：持续集成与备份

良好的版本控制和备份策略是保护项目数据的关键。在这一章节，我们将设置自动化的版本控制和备份系统。

### 8.1 GitHub仓库配置

#### 步骤一：设置分支保护

1. 访问GitHub仓库页面
2. 进入「Settings → Branches」
3. 添加分支保护规则：
   - 保护main分支
   - 要求Pull Request审查
   - 要求状态检查通过
   - 限制强制推送

#### 步骤二：设置仓库徽章

在README.md中添加状态徽章：

```markdown
![Unity Version](https://img.shields.io/badge/Unity-2022.3.62f2c1-blue)
![License](https://img.shields.io/badge/License-MIT-green)
```

#### 步骤三：创建Issue模板

创建Issue模板，提高Bug报告质量：

- **Bug报告模板**
- **功能请求模板**
- **改进建议模板**

### 8.2 自动备份策略

#### 步骤一：本地备份脚本

创建批处理脚本实现本地备份：

**Windows (backup.bat)：**
```batch
@echo off
set BACKUP_DIR=.\Backups
set DATE=%date:~0,4%%date:~5,2%%date:~8,2%
set TIME=%time:~0,2%%time:~3,2%
set BACKUP_NAME=DayAndNight_%DATE%_%TIME%

echo 正在创建备份...
mkdir "%BACKUP_DIR%\%BACKUP_NAME%"

echo 备份Assets目录...
xcopy /E /I "Assets" "%BACKUP_DIR%\%BACKUP_NAME%\Assets"

echo 备份项目配置...
xcopy "*.sln" "%BACKUP_DIR%\%BACKUP_NAME%" >nul
xcopy "*.csproj" "%BACKUP_DIR%\%BACKUP_NAME%" >nul

echo 备份完成！
pause
```

#### 步骤二：云端同步

使用GitHub Actions实现自动同步：

1. 创建 `.github/workflows/sync.yml`
2. 配置自动同步到云存储（如Google Drive）

#### 步骤三：定期归档

创建每月归档脚本：

```bash
#!/bin/bash
# monthly_archive.sh

BACKUP_DIR="./Archive"
DATE=$(date +%Y%m)

mkdir -p "$BACKUP_DIR"

# 创建月度归档
tar -czvf "$BACKUP_DIR/monthly_backup_$DATE.tar.gz" \
    --exclude='.git' \
    --exclude='Library' \
    --exclude='Builds' \
    --exclude='Temp' \
    .

# 清理旧备份（保留最近6个月）
find "$BACKUP_DIR" -name "monthly_backup_*.tar.gz" -mtime +180d -delete
```

### 8.3 版本发布流程

#### 步骤一：版本号规范

采用语义化版本号（SemVer）：

- **主版本（Major）**：重大功能更新或不兼容的API变更
- **次版本（Minor）**：新增功能（向后兼容）
- **修订号（Patch）**：Bug修复（向后兼容）

格式：`Major.Minor.Patch`（例如：1.0.0、1.1.0、1.1.1）

#### 步骤二：创建发布分支

1. 从develop分支创建发布分支
2. 在发布分支上进行最后的测试和修复
3. 完成测试后合并到main分支
4. 创建版本标签（Tag）

#### 步骤三：自动构建脚本

创建构建脚本，实现一键构建：

```csharp
// Editor/BuildScript.cs
public class BuildScript
{
    [MenuItem("Build/Build Windows")]
    public static void BuildWindows()
    {
        BuildPipeline.BuildPlayer(GetScenePaths(), 
            "Builds/Windows/DayAndNight.exe", 
            BuildTarget.StandaloneWindows, 
            BuildOptions.None);
    }
    
    [MenuItem("Build/Build macOS")]
    public static void BuildMacOS()
    {
        BuildPipeline.BuildPlayer(GetScenePaths(), 
            "Builds/macOS/DayAndNight.app", 
            BuildTarget.StandaloneOSX, 
            BuildOptions.None);
    }
}
```

---

## ✅ 第九章：项目验证清单

在完成所有配置后，使用以下清单验证项目是否正确初始化。

### 9.1 环境验证

**Unity版本验证：**
- [ ] Unity Editor版本为2022.3.62f2c1
- [ ] Visual Studio 2022正确集成
- [ ] Package Manager中所有必需包已安装

**开发工具验证：**
- [ ] Git已安装并正确配置
- [ ] GitHub仓库已创建并连接
- [ ] Aseprite已安装（如需要）

### 9.2 项目结构验证

**目录结构验证：**
- [ ] Assets/_Project/Scripts目录结构正确
- [ ] Assets/_Project/Scenes目录存在
- [ ] Assets/_Project/Prefabs目录存在
- [ ] Assets/_Project/Art目录结构正确
- [ ] Assets/_Project/Audio目录结构正确
- [ ] Assets/_Project/Data目录结构正确
- [ ] Assets/Plugins目录存在

**Git配置验证：**
- [ ] .gitignore文件已创建并正确配置
- [ ] .gitattributes文件已创建并正确配置
- [ ] 本地Git仓库已初始化
- [ ] 远程仓库已连接
- [ ] 初始提交已推送

### 9.3 核心功能验证

**管理器验证：**
- [ ] GameManager脚本已创建
- [ ] TimeManager脚本已创建
- [ ] EventManager脚本已创建
- [ ] AudioManager脚本已创建
- [ ] SaveManager脚本已创建

**预制体验证：**
- [ ] GameManagers预制体已创建
- [ ] 主场景已创建
- [ ] 游戏场景已创建

### 9.4 开发环境验证

**编码规范验证：**
- [ ] 命名规范文档已创建
- [ ] Git提交规范已定义
- [ ] 注释规范已定义

**工具配置验证：**
- [ ] 开发者控制台已实现
- [ ] FPS计数器已实现
- [ ] 性能监控面板已实现
- [ ] 测试模式已实现

### 9.5 文档验证

**必需文档：**
- [ ] README.md已创建并填写项目信息
- [ ] CONTRIBUTING.md已创建
- [ ] CHANGELOG.md已创建
- [ ] 项目工程准备文档已创建

---

## 📚 附录

### 附录A：常用终端命令速查

**Git命令：**
```bash
git status                    # 查看当前状态
git add .                     # 添加所有文件到暂存区
git commit -m "消息"          # 提交更改
git push                      # 推送到远程仓库
git pull                      # 拉取远程更改
git checkout -b 分支名        # 创建并切换到新分支
git merge 分支名              # 合并分支
git log --oneline             # 查看提交历史
```

**目录操作命令：**
```bash
cd 路径                       # 切换目录
ls 或 dir                    # 列出文件
mkdir 目录名                  # 创建目录
pwd 或 cd                    # 查看当前目录
```

### 附录B：快捷键速查

**Unity Editor快捷键：**
- `Ctrl+S` - 保存场景
- `Ctrl+Shift+S` - 保存所有
- `Ctrl+P` - 播放游戏
- `Ctrl+Shift+P` - 暂停游戏
- `Ctrl+Alt+P` - 逐帧执行
- `F` - 聚焦选中对象
- `Ctrl+Shift+F` - 将相机对准选中对象
- `Tab` - 切换Inspector锁定

**Visual Studio快捷键：**
- `F5` - 开始调试
- `F9` - 切换断点
- `F10` - 单步跳过
- `F11` - 单步进入
- `Ctrl+K, Ctrl+D` - 格式化文档
- `Ctrl+R, Ctrl+R` - 重命名

### 附录C：资源链接

- Unity官方文档：https://docs.unity3d.com/
- Unity中文文档：https://docs.unity3d.com/cn/
- Unity Asset Store：https://assetstore.unity.com/
- GitHub：https://github.com/
- Aseprite：https://www.aseprite.org/
- Yarn Spinner：https://yarnspinner.dev/

---

## 📝 更新日志

| 版本 | 日期 | 更新内容 |
|------|------|----------|
| 1.0.0 | 2026-02-03 | 初始版本，完成项目工程准备指南 |

---

**文档版本：** 1.0.0  
**最后更新：** 2026-02-03  
**维护者：** 项目开发团队

本指南将随项目进展持续更新，如有疑问或建议，请提交Issue或联系维护团队。
